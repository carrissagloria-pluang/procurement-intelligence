# -*- coding: utf-8 -*-
"""git - report generation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c3BmgHLNwp0_fsd5_eVnAV4ZYSvvYoxV

# Setup
"""

!pip install -q -U google-genai

!pip install google-api-python-client

!pip install supabase

from google import genai
import numpy as np
import pandas as pd
import datetime as dt
from datetime import datetime, timedelta
import os.path
import markdown
import json
import requests
from supabase import create_client, Client

import google.auth
from googleapiclient.http import MediaInMemoryUpload
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
import base64
from email.message import EmailMessage

"""# OAuth credentials"""

SCOPES = [
    'https://www.googleapis.com/auth/drive.file',
    'https://www.googleapis.com/auth/gmail.send',
    'https://www.googleapis.com/auth/spreadsheets.readonly'
]

# Get the initial token to allow for a hybrid authentication system
from google_auth_oauthlib.flow import Flow

# 1. Setup the flow manually
flow = Flow.from_client_secrets_file(
    'credentials.json',
    scopes=SCOPES,
    redirect_uri='urn:ietf:wg:oauth:2.0:oob' # This tells Google "no redirect, give me a code"
)

# 2. Get the URL to click
auth_url, _ = flow.authorization_url(prompt='consent')
print(f'Please go to this URL and authorize: {auth_url}')

# 3. This line WILL create the "enter box" you are looking for
code = input('Enter the authorization code: ')

# 4. Exchange the code for the final token
flow.fetch_token(code=code)
creds = flow.credentials

# 5. Save it as always
with open('token.json', 'w') as token:
    token.write(creds.to_json())

def authenticate_github():
    creds = None

    # 1. Try to load from Environment Variables (GitHub Actions)
    # These are stored as Secrets in your repo settings
    creds_json_str = os.environ.get('CREDENTIALS_JSON')
    token_json_str = os.environ.get('TOKEN_JSON')

    if creds_json_str and token_json_str:
        # Load directly from the strings
        creds = Credentials.from_authorized_user_info(json.loads(token_json_str), SCOPES)

    # 2. Fallback to local files (Development/Testing)
    elif os.path.exists('token.json'):
        with open('token.json', 'r') as f:
            creds = Credentials.from_authorized_user_info(json.load(f), SCOPES)

    # 3. Refresh the token if it's expired
    if creds and creds.expired and creds.refresh_token:
        creds.refresh(Request())

    if not creds:
        raise Exception("No credentials found! Ensure Secrets are set in GitHub.")

    return creds

# Build services
creds = authenticate_github()

"""# Get Sheets Data"""

def read_sheet_data(creds, spreadsheet_id, range_name):
    # 1. Initialize the Sheets service
    service = build('sheets', 'v4', credentials=creds)

    # 2. Call the Sheets API
    try:
        sheet = service.spreadsheets()
        result = sheet.values().get(
            spreadsheetId=spreadsheet_id,
            range=range_name
        ).execute()

        # 3. Extract the data (it comes as a list of lists)
        values = result.get('values', [])

        if not values:
            print('No data found.')
            return []

        return values

    except Exception as e:
        print(f"An error occurred: {e}")
        return None

# Usage example:
SPREADSHEET_ID = os.environ.get('SPREADSHEET_ID')
RANGE_NAME = "Tender Date!A1:E" # Reads everything in columns A through E
tender_data = read_sheet_data(creds, SPREADSHEET_ID, RANGE_NAME)

tender_df = pd.DataFrame(tender_data)
new_header = tender_df.iloc[0]
tender_df = tender_df[1:]
tender_df.columns = new_header

tender_df.info()

# change the 'Tender Date' data type
tender_df['Tender Date'] = pd.to_datetime(tender_df['Tender Date'], format='%d/%m/%Y')

# loop through to select tender within 1 week
gen_report = []

for i in range(len(tender_df)):
  tender = tender_df.iloc[i]
  tender_date = tender['Tender Date']
  if (tender_date - datetime.now() <= timedelta(days=7)) and (tender_date > datetime.now()):
    gen_report.append(i)

gen_report

"""# Gemini API - report generation"""

# data for testing purposes
tender_data = tender_df.iloc[1]
tender_data

# initialize the model
api_key = os.environ.get('GEMINI_API_KEY')
client = genai.Client(api_key=api_key)
chat = client.chats.create(model="gemini-3-flash-preview")

def create_prompt(tender_data):
  category = tender_data['Category']
  vendor = tender_data['Vendor Name']
  contract_length = tender_data['Contract Length']
  currency = tender_data['Currency']

  prompt = f"""
    Role: You are an elite, senior Procurement Intelligence Analyst. Your objective is to conduct deep, exhaustive web research and synthesize a highly strategic, executive-level category intelligence report.

    Task: Conduct a deep-dive market analysis on the following category and vendor.

    - Category Focus: {category}
    - Current Vendor: {vendor}
    - Our Base Currency: {currency}
    - Contract Timeline: {contract_length}

    Instructions: Scour recent financial reports, tech news, analyst insights (Gartner/Forrester), G2/Capterra reviews, pricing databases, and M&A press releases to answer the following parameters comprehensively. If exact private data (like specific B2B pricing) is unavailable, provide the most accurate market estimates, averages, or proxies. Include the sources you used to generate the procurement intelligence as a citation with the source name as the display text and an embedded link on that display text.

    ### 1. Supplier Landscape Map

    - Market Dynamics: How is this supplier landscape shaped? Is it a monopoly, an oligopoly, or a highly competitive/fragmented market?
    - Market Leaders: Who are the major market shareholders? Are they financially healthy and faring well?
    - Incumbent Status: How is {vendor} faring in the market right now? Have they lost market share, are they growing, or are they being driven out?
    - M&A Activity: Have there been any recent mergers or acquisitions involving {vendor} or top competitors that might force product migration or price hikes?
    - Technological Disruption: Is there a new technology (e.g., AI, automation) that makes this service obsolete or significantly cheaper to deliver?
    - Product Roadmaps: What does the product roadmap look like for this category? What new tech/implementations are competitors utilizing that {vendor} is lacking?
    - Reputation: What are the objective reputations and recent customer reviews of the top competitors compared to {vendor}?

    ### 2. Pricing & Packaging Intelligence

    - Cost Drivers: Are the base resources/operating costs (e.g., raw materials, cloud hosting, labor) for this category going up or down? How does that correlate to {vendor}'s pricing?
    - Macro Factors: Is inflation drastically affecting the base price? If {vendor} is paid in a foreign currency, have exchange rates shifted in our favor or against us since the last contract?
    - Market Benchmarks: What are other companies currently paying for this same service? Is {vendor}'s pricing in line with the market mean?
    - Price Trajectory: Did the market price change during our contract period? Are market prices projected to go up or down in the future, and by how much?
    - Packaging Shifts: Is the market offering alternative payment methods (e.g., pay-as-you-go, upfront discounts, installments)? Can changing our payment method yield a cheaper price (e.g., paying upfront for a standard 20% discount)?
    - Product Alignment: Have there been recent changes to how this product is packaged or used in the market? Does the market standard still align with our current usage?

    ### 3. Negotiation Levers & Risk Watch-Outs

    - Vendor Vulnerability: Is {vendor} facing any financial difficulties, public controversies, or reputational damage? (We will use this as leverage).
    - Compliance & Security: Are there new laws or regulatory compliances that {vendor} should now include in their base price instead of charging a premium? Are they fulfilling modern security standards?
    - Historical Issues: Have there been any systemic, publicized outages or problems with {vendor} in the recent past?
    - Toxic Clauses: Based on industry standards, what "toxic clauses" (e.g., aggressive auto-renewals, data hostage fees) should we look out for in {vendor}'s and competitors' contracts?

    ### 4. Shortlist of Alternatives

    - Top 3-5 Competitors: Provide a shortlist of the most viable alternative vendors to consider.
    - Differentiation: Are these competitors offering additional services or features that {vendor} does not?
    - Switching Costs: What is the estimated implementation/migration cost (explicitly state the approximate cost) and timeline to switch to these competitors?
    - Integration: Do these shortlisted vendors historically integrate seamlessly with standard enterprise operations?

    Output Format:
    Present this research in a highly structured 3-5 page report using bold headings, bullet points, and concise executive summaries (do not include long irrelevant explanations). Where data is definitively known, state the facts. Where data is estimated, clearly state "Market Estimate." Conclude the report with a dedicated section titled "Top 3 Negotiation Levers," explicitly stating the best angles I can use against {vendor} to secure a better deal and Top 3 competitors to consider, explicitly state the reason for considering the new competitor and their drawbacks compared to the current vendor. Only includes relevant information for vendor negotiation by the procurement team. Do not include unneeded technical jargon that provides no function to the contract negotiation.
  """
  return prompt

create_prompt(tender_data)

# send the prompt for procurement intelligence report generation
def generate_report(tender_data):
  prompt = create_prompt(tender_data)

  response = chat.send_message(prompt)

  print(response.text)

  for message in chat.get_history():
      print(f'role - {message.role}',end=": ")
      print(message.parts[0].text)

  return response

response = generate_report(tender_data)

response

"""# Save to Drive"""

# upload response to google drive folder
def upload_markdown_as_doc(creds, title, markdown_content):
    drive_service = build('drive', 'v3', credentials=creds)

    # 1. Convert your Markdown string into HTML
    html_content = markdown.markdown(markdown_content)
    folder_id = os.environ.get('DRIVE_FOLDER_ID')

    # 2. Metadata stays the same (target is a Google Doc)
    file_metadata = {
        'name': title,
        'mimeType': 'application/vnd.google-apps.document',
        'parents': [folder_id]
    }

    # 3. CRITICAL CHANGE: Set source mimetype to 'text/html'
    # Google's converter sees HTML and applies formatting automatically.
    media = MediaInMemoryUpload(html_content.encode('utf-8'), mimetype='text/html')

    try:
        file = drive_service.files().create(
            body=file_metadata,
            media_body=media,
            fields='id, webViewLink'
        ).execute()

        print(f"File ID: {file.get('id')}")
        print(f"View Link: {file.get('webViewLink')}")
        return file.get('id')

    except Exception as e:
        print(f"An error occurred: {e}")
        return None

# Example Usage
# my_text = "# Header 1\n**Bold Text** and *Italic Text*\n- List item 1\n- List item 2"
title = tender_data['Category']+"-"+tender_data['Vendor Name']
# title
upload_markdown_as_doc(creds, title, response.text)

"""# Send to Email"""

def send_formatted_markdown_email(creds, recipient, subject, markdown_text):
    service = build('gmail', 'v1', credentials=creds)

    # 1. Convert Markdown string to HTML string
    html_version = markdown.markdown(markdown_text)

    # 2. Build the Email Message
    message = EmailMessage()
    message['Subject'] = subject
    message['To'] = recipient
    message['From'] = 'me'

    # Set the fallback plain text (for old email apps)
    message.set_content(markdown_text)

    # For the chat button
    button_style = (
        "display: inline-block; "
        "padding: 12px 24px; "
        "background-color: #1a73e8; " # Google Blue
        "color: #ffffff; "
        "text-decoration: none; "
        "border-radius: 4px; "
        "font-weight: bold; "
        "font-family: Arial, sans-serif;"
    )

    # Add the HTML version as the "rich text" alternative
    message.add_alternative(f"""
    <html>
      <body style="font-family: Arial, sans-serif; line-height: 1.6;">
        {html_version}
        <br><br>
        <div style="text-align: center;">
            <a href="{'youtube.com'}" style="{button_style}">
                Chat/Ask More
            </a>
        </div>
      </body>
    </html>
    """, subtype='html')

    # 3. Encode and Send
    raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode()

    try:
        sent_msg = service.users().messages().send(
            userId='me',
            body={'raw': raw_message}
        ).execute()
        print(f"Formatted email sent! ID: {sent_msg['id']}")
    except Exception as e:
        print(f"Error sending email: {e}")

subject = "Procurement Intelligence Report -"+tender_data['Category']+"-"+tender_data['Vendor Name']
markdown_text = response.text
send_formatted_markdown_email(creds, 'carrissa.gloria@pluang.com', subject, markdown_text)

"""# Save to Supabase"""

# initialize the supabase client
supabase = create_client(SUPABASE_URL, SUPABASE_SERVICE_KEY)

# upload file to file storage

def upload_markdown_to_supabase(markdown_string, bucket, file_path, project_url, service_key):
    # Construct the endpoint
    # Example: https://xyz.supabase.co/storage/v1/object/my-bucket/folder/report.md
    url = f"{project_url}/storage/v1/object/{bucket}/{file_path}"

    headers = {
        "Authorization": f"Bearer {service_key}",
        "apiKey": service_key,
        "Content-Type": "text/markdown"  # Tells Supabase this is Markdown
    }

    # Encode the string to bytes
    data = markdown_string.encode('utf-8')

    # Use POST to create, or PUT to overwrite/update
    response = requests.post(url, headers=headers, data=data)

    if response.status_code == 200:
        print(f"Successfully uploaded {file_path} to Supabase!")
    else:
        print(f"Upload failed: {response.status_code} - {response.text}")

# Usage:
bucket = os.environ.get('supabase_bucket')
upload_markdown_to_supabase(response.text, bucket, f"{title}.md", SUPABASE_URL, SUPABASE_SERVICE_KEY)

